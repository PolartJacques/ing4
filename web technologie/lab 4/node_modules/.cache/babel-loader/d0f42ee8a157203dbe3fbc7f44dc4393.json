{"ast":null,"code":"/**\n * @typedef {import('hast').Root} Root\n * @typedef {Root['children'][number]} Child\n * @typedef {import('hast').Element} Element\n * @typedef {Root|Child} Node\n *\n * @typedef Options\n *   Configuration.\n * @property {number|string} [indent=2]\n *   Indentation per level (`number`, `string`, default: `2`).\n *   When number, uses that amount of spaces.\n *   When `string`, uses that per indentation level.\n * @property {boolean} [indentInitial=true]\n *   Whether to indent the first level (`boolean`, default: `true`).\n *   This is usually the `<html>`, thus not indenting `head` and `body`.\n * @property {string[]} [blanks=[]]\n *   List of tag names to join with a blank line (`Array.<string>`, default:\n *   `[]`).\n *   These tags, when next to each other, are joined by a blank line (`\\n\\n`).\n *   For example, when `['head', 'body']` is given, a blank line is added\n *   between these two.\n */\nimport rehypeMinifyWhitespace from 'rehype-minify-whitespace';\nimport { visitParents, SKIP } from 'unist-util-visit-parents';\nimport { embedded } from 'hast-util-embedded';\nimport { phrasing } from 'hast-util-phrasing';\nimport { whitespace } from 'hast-util-whitespace';\nimport { isElement } from 'hast-util-is-element';\nimport { whitespaceSensitiveTagNames } from 'html-whitespace-sensitive-tag-names';\nconst minify = rehypeMinifyWhitespace({\n  newlines: true\n});\n/**\n * @type {import('unified').Plugin<[Options?] | void[], Root>}\n */\n\nexport default function rehypeFormat(options = {}) {\n  let indent = options.indent || 2;\n  let indentInitial = options.indentInitial;\n\n  if (typeof indent === 'number') {\n    indent = ' '.repeat(indent);\n  } // Default to indenting the initial level.\n\n\n  if (indentInitial === null || indentInitial === undefined) {\n    indentInitial = true;\n  }\n\n  return tree => {\n    /** @type {boolean|undefined} */\n    let head; // @ts-expect-error: fine, it’s a sync transformer.\n\n    minify(tree); // eslint-disable-next-line complexity\n\n    visitParents(tree, (node, parents) => {\n      let index = -1;\n\n      if (!('children' in node)) {\n        return;\n      }\n\n      if (isElement(node, 'head')) {\n        head = true;\n      }\n\n      if (head && isElement(node, 'body')) {\n        head = undefined;\n      }\n\n      if (isElement(node, whitespaceSensitiveTagNames)) {\n        return SKIP;\n      }\n\n      const children = node.children;\n      let level = parents.length; // Don’t indent content of whitespace-sensitive nodes / inlines.\n\n      if (children.length === 0 || !padding(node, head)) {\n        return;\n      }\n\n      if (!indentInitial) {\n        level--;\n      }\n      /** @type {boolean|undefined} */\n\n\n      let eol; // Indent newlines in `text`.\n\n      while (++index < children.length) {\n        const child = children[index];\n\n        if (child.type === 'text' || child.type === 'comment') {\n          if (child.value.includes('\\n')) {\n            eol = true;\n          }\n\n          child.value = child.value.replace(/ *\\n/g, '$&' + String(indent).repeat(level));\n        }\n      }\n      /** @type {Child[]} */\n\n\n      const result = [];\n      /** @type {Child|undefined} */\n\n      let previous;\n      index = -1;\n\n      while (++index < children.length) {\n        const child = children[index];\n\n        if (padding(child, head) || eol && !index) {\n          addBreak(result, level, child);\n          eol = true;\n        }\n\n        previous = child;\n        result.push(child);\n      }\n\n      if (previous && (eol || padding(previous, head))) {\n        // Ignore trailing whitespace (if that already existed), as we’ll add\n        // properly indented whitespace.\n        if (whitespace(previous)) {\n          result.pop();\n          previous = result[result.length - 1];\n        }\n\n        addBreak(result, level - 1);\n      }\n\n      node.children = result;\n    });\n  };\n  /**\n   * @param {Child[]} list\n   * @param {number} level\n   * @param {Child} [next]\n   * @returns {void}\n   */\n\n  function addBreak(list, level, next) {\n    const tail = list[list.length - 1];\n    const previous = whitespace(tail) ? list[list.length - 2] : tail;\n    const replace = (blank(previous) && blank(next) ? '\\n\\n' : '\\n') + String(indent).repeat(Math.max(level, 0));\n\n    if (tail && tail.type === 'text') {\n      tail.value = whitespace(tail) ? replace : tail.value + replace;\n    } else {\n      list.push({\n        type: 'text',\n        value: replace\n      });\n    }\n  }\n  /**\n   * @param {Node|undefined} node\n   * @returns {boolean}\n   */\n\n\n  function blank(node) {\n    return Boolean(node && node.type === 'element' && options.blanks && options.blanks.length > 0 && options.blanks.includes(node.tagName));\n  }\n}\n/**\n * @param {Node} node\n * @param {boolean|undefined} head\n * @returns {boolean}\n */\n\nfunction padding(node, head) {\n  return node.type === 'root' || (node.type === 'element' ? head || isElement(node, 'script') || embedded(node) || !phrasing(node) : false);\n}","map":{"version":3,"sources":["/home/jacques/Documents/ece/inge4/techno web/lab/lab 4/lab/node_modules/rehype-format/index.js"],"names":["rehypeMinifyWhitespace","visitParents","SKIP","embedded","phrasing","whitespace","isElement","whitespaceSensitiveTagNames","minify","newlines","rehypeFormat","options","indent","indentInitial","repeat","undefined","tree","head","node","parents","index","children","level","length","padding","eol","child","type","value","includes","replace","String","result","previous","addBreak","push","pop","list","next","tail","blank","Math","max","Boolean","blanks","tagName"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('hast').Root} Root\n * @typedef {Root['children'][number]} Child\n * @typedef {import('hast').Element} Element\n * @typedef {Root|Child} Node\n *\n * @typedef Options\n *   Configuration.\n * @property {number|string} [indent=2]\n *   Indentation per level (`number`, `string`, default: `2`).\n *   When number, uses that amount of spaces.\n *   When `string`, uses that per indentation level.\n * @property {boolean} [indentInitial=true]\n *   Whether to indent the first level (`boolean`, default: `true`).\n *   This is usually the `<html>`, thus not indenting `head` and `body`.\n * @property {string[]} [blanks=[]]\n *   List of tag names to join with a blank line (`Array.<string>`, default:\n *   `[]`).\n *   These tags, when next to each other, are joined by a blank line (`\\n\\n`).\n *   For example, when `['head', 'body']` is given, a blank line is added\n *   between these two.\n */\n\nimport rehypeMinifyWhitespace from 'rehype-minify-whitespace'\nimport {visitParents, SKIP} from 'unist-util-visit-parents'\nimport {embedded} from 'hast-util-embedded'\nimport {phrasing} from 'hast-util-phrasing'\nimport {whitespace} from 'hast-util-whitespace'\nimport {isElement} from 'hast-util-is-element'\nimport {whitespaceSensitiveTagNames} from 'html-whitespace-sensitive-tag-names'\n\nconst minify = rehypeMinifyWhitespace({newlines: true})\n\n/**\n * @type {import('unified').Plugin<[Options?] | void[], Root>}\n */\nexport default function rehypeFormat(options = {}) {\n  let indent = options.indent || 2\n  let indentInitial = options.indentInitial\n\n  if (typeof indent === 'number') {\n    indent = ' '.repeat(indent)\n  }\n\n  // Default to indenting the initial level.\n  if (indentInitial === null || indentInitial === undefined) {\n    indentInitial = true\n  }\n\n  return (tree) => {\n    /** @type {boolean|undefined} */\n    let head\n\n    // @ts-expect-error: fine, it’s a sync transformer.\n    minify(tree)\n\n    // eslint-disable-next-line complexity\n    visitParents(tree, (node, parents) => {\n      let index = -1\n\n      if (!('children' in node)) {\n        return\n      }\n\n      if (isElement(node, 'head')) {\n        head = true\n      }\n\n      if (head && isElement(node, 'body')) {\n        head = undefined\n      }\n\n      if (isElement(node, whitespaceSensitiveTagNames)) {\n        return SKIP\n      }\n\n      const children = node.children\n      let level = parents.length\n\n      // Don’t indent content of whitespace-sensitive nodes / inlines.\n      if (children.length === 0 || !padding(node, head)) {\n        return\n      }\n\n      if (!indentInitial) {\n        level--\n      }\n\n      /** @type {boolean|undefined} */\n      let eol\n\n      // Indent newlines in `text`.\n      while (++index < children.length) {\n        const child = children[index]\n\n        if (child.type === 'text' || child.type === 'comment') {\n          if (child.value.includes('\\n')) {\n            eol = true\n          }\n\n          child.value = child.value.replace(\n            / *\\n/g,\n            '$&' + String(indent).repeat(level)\n          )\n        }\n      }\n\n      /** @type {Child[]} */\n      const result = []\n      /** @type {Child|undefined} */\n      let previous\n\n      index = -1\n\n      while (++index < children.length) {\n        const child = children[index]\n\n        if (padding(child, head) || (eol && !index)) {\n          addBreak(result, level, child)\n          eol = true\n        }\n\n        previous = child\n        result.push(child)\n      }\n\n      if (previous && (eol || padding(previous, head))) {\n        // Ignore trailing whitespace (if that already existed), as we’ll add\n        // properly indented whitespace.\n        if (whitespace(previous)) {\n          result.pop()\n          previous = result[result.length - 1]\n        }\n\n        addBreak(result, level - 1)\n      }\n\n      node.children = result\n    })\n  }\n\n  /**\n   * @param {Child[]} list\n   * @param {number} level\n   * @param {Child} [next]\n   * @returns {void}\n   */\n  function addBreak(list, level, next) {\n    const tail = list[list.length - 1]\n    const previous = whitespace(tail) ? list[list.length - 2] : tail\n    const replace =\n      (blank(previous) && blank(next) ? '\\n\\n' : '\\n') +\n      String(indent).repeat(Math.max(level, 0))\n\n    if (tail && tail.type === 'text') {\n      tail.value = whitespace(tail) ? replace : tail.value + replace\n    } else {\n      list.push({type: 'text', value: replace})\n    }\n  }\n\n  /**\n   * @param {Node|undefined} node\n   * @returns {boolean}\n   */\n  function blank(node) {\n    return Boolean(\n      node &&\n        node.type === 'element' &&\n        options.blanks &&\n        options.blanks.length > 0 &&\n        options.blanks.includes(node.tagName)\n    )\n  }\n}\n\n/**\n * @param {Node} node\n * @param {boolean|undefined} head\n * @returns {boolean}\n */\nfunction padding(node, head) {\n  return (\n    node.type === 'root' ||\n    (node.type === 'element'\n      ? head || isElement(node, 'script') || embedded(node) || !phrasing(node)\n      : false)\n  )\n}\n"]},"metadata":{},"sourceType":"module"}