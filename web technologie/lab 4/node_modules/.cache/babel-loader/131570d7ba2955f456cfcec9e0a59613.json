{"ast":null,"code":"/**\n * @fileoverview\n *   Collapse whitespace.\n *\n *   Normally, collapses to a single space.\n *   If `newlines: true`, collapses whitespace containing newlines to `'\\n'`\n *   instead of `' '`.\n * @example\n *   <h1>Heading</h1>\n *   <p><strong>This</strong> and <em>that</em></p>\n */\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {Root|Root['children'][number]} Node\n *\n * @typedef Options\n * @property {boolean} [newlines=false]\n *   If `newlines: true`, collapses whitespace containing newlines to `'\\n'`\n *   instead of `' '`.\n *   The default is to collapse to a single space.\n *\n * @typedef {'pre'|'nowrap'|'pre-wrap'|'normal'} Whitespace\n *\n * @typedef Context\n * @property {ReturnType<collapseFactory>} collapse\n * @property {Whitespace} whitespace\n * @property {boolean} [before]\n * @property {boolean} [after]\n *\n * @typedef Result\n * @property {boolean} remove\n * @property {boolean} ignore\n * @property {boolean} stripAtStart\n */\nimport { isElement } from 'hast-util-is-element';\nimport { embedded } from 'hast-util-embedded';\nimport { convert } from 'unist-util-is';\nimport { whitespace } from 'hast-util-whitespace';\nimport { blocks } from './block.js';\nimport { content as contents } from './content.js';\nimport { skippable as skippables } from './skippable.js';\nconst ignorableNode = convert(['doctype', 'comment']);\n/**\n * Collapse whitespace.\n *\n * Normally, collapses to a single space.\n * If `newlines: true`, collapses whitespace containing newlines to `'\\n'`\n * instead of `' '`.\n *\n * @type {import('unified').Plugin<[Options?] | void[], Root>}\n */\n\nexport default function rehypeMinifyWhitespace(options = {}) {\n  const collapse = collapseFactory(options.newlines ? replaceNewlines : replaceWhitespace);\n  return tree => {\n    minify(tree, {\n      collapse,\n      whitespace: 'normal'\n    });\n  };\n}\n/**\n * @param {Node} node\n * @param {Context} context\n * @returns {Result}\n */\n\nfunction minify(node, context) {\n  if ('children' in node) {\n    const settings = Object.assign({}, context);\n\n    if (node.type === 'root' || blocklike(node)) {\n      settings.before = true;\n      settings.after = true;\n    }\n\n    settings.whitespace = inferWhiteSpace(node, context);\n    return all(node, settings);\n  }\n\n  if (node.type === 'text') {\n    if (context.whitespace === 'normal') {\n      return minifyText(node, context);\n    } // Naïve collapse, but no trimming:\n\n\n    if (context.whitespace === 'nowrap') {\n      node.value = context.collapse(node.value);\n    } // The `pre-wrap` or `pre` whitespace settings are neither collapsed nor\n    // trimmed.\n\n  }\n\n  return {\n    remove: false,\n    ignore: ignorableNode(node),\n    stripAtStart: false\n  };\n}\n/**\n * @param {Text} node\n * @param {Context} context\n * @returns {Result}\n */\n\n\nfunction minifyText(node, context) {\n  const value = context.collapse(node.value);\n  const result = {\n    remove: false,\n    ignore: false,\n    stripAtStart: false\n  };\n  let start = 0;\n  let end = value.length;\n\n  if (context.before && removable(value.charAt(0))) {\n    start++;\n  }\n\n  if (start !== end && removable(value.charAt(end - 1))) {\n    if (context.after) {\n      end--;\n    } else {\n      result.stripAtStart = true;\n    }\n  }\n\n  if (start === end) {\n    result.remove = true;\n  } else {\n    node.value = value.slice(start, end);\n  }\n\n  return result;\n}\n/**\n * @param {Root|Element} parent\n * @param {Context} context\n * @returns {Result}\n */\n\n\nfunction all(parent, context) {\n  let before = context.before;\n  const after = context.after;\n  const children = parent.children;\n  let length = children.length;\n  let index = -1;\n\n  while (++index < length) {\n    const result = minify(children[index], Object.assign({}, context, {\n      before,\n      after: collapsableAfter(children, index, after)\n    }));\n\n    if (result.remove) {\n      children.splice(index, 1);\n      index--;\n      length--;\n    } else if (!result.ignore) {\n      before = result.stripAtStart;\n    } // If this element, such as a `<select>` or `<img>`, contributes content\n    // somehow, allow whitespace again.\n\n\n    if (content(children[index])) {\n      before = false;\n    }\n  }\n\n  return {\n    remove: false,\n    ignore: false,\n    stripAtStart: Boolean(before || after)\n  };\n}\n/**\n * @param {Node[]} nodes\n * @param {number} index\n * @param {boolean|undefined} [after]\n * @returns {boolean|undefined}\n */\n\n\nfunction collapsableAfter(nodes, index, after) {\n  while (++index < nodes.length) {\n    const node = nodes[index];\n    let result = inferBoundary(node);\n\n    if (result === undefined && 'children' in node && !skippable(node)) {\n      result = collapsableAfter(node.children, -1);\n    }\n\n    if (typeof result === 'boolean') {\n      return result;\n    }\n  }\n\n  return after;\n}\n/**\n * Infer two types of boundaries:\n *\n * 1. `true` — boundary for which whitespace around it does not contribute\n *    anything\n * 2. `false` — boundary for which whitespace around it *does* contribute\n *\n * No result (`undefined`) is returned if it is unknown.\n *\n * @param {Node} node\n * @returns {boolean|undefined}\n */\n\n\nfunction inferBoundary(node) {\n  if (node.type === 'element') {\n    if (content(node)) {\n      return false;\n    }\n\n    if (blocklike(node)) {\n      return true;\n    } // Unknown: either depends on siblings if embedded or metadata, or on\n    // children.\n\n  } else if (node.type === 'text') {\n    if (!whitespace(node)) {\n      return false;\n    }\n  } else if (!ignorableNode(node)) {\n    return false;\n  }\n}\n/**\n * Infer whether a node is skippable.\n *\n * @param {Node} node\n * @returns {boolean}\n */\n\n\nfunction content(node) {\n  return embedded(node) || isElement(node, contents);\n}\n/**\n * See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\n *\n * @param {Element} node\n * @returns {boolean}\n */\n\n\nfunction blocklike(node) {\n  return isElement(node, blocks);\n}\n/**\n * @param {Element|Root} node\n * @returns {boolean}\n */\n\n\nfunction skippable(node) {\n  return Boolean('properties' in node && node.properties && node.properties.hidden) || ignorableNode(node) || isElement(node, skippables);\n}\n/**\n * @param {string} character\n * @returns {boolean}\n */\n\n\nfunction removable(character) {\n  return character === ' ' || character === '\\n';\n}\n/**\n * @param {string} value\n * @returns {string}\n */\n\n\nfunction replaceNewlines(value) {\n  const match = /\\r?\\n|\\r/.exec(value);\n  return match ? match[0] : ' ';\n}\n/**\n * @returns {string}\n */\n\n\nfunction replaceWhitespace() {\n  return ' ';\n}\n/**\n * @param {(value: string) => string} replace\n */\n\n\nfunction collapseFactory(replace) {\n  return collapse;\n  /**\n   * @param {string} value\n   * @returns {string}\n   */\n\n  function collapse(value) {\n    return String(value).replace(/[\\t\\n\\v\\f\\r ]+/g, replace);\n  }\n}\n/**\n * We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\n *\n * @param {Root|Element} node\n * @param {Context} context\n * @returns {Whitespace}\n */\n\n\nfunction inferWhiteSpace(node, context) {\n  if ('tagName' in node && node.properties) {\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp':\n        return 'pre';\n\n      case 'nobr':\n        return 'nowrap';\n\n      case 'pre':\n        return node.properties.wrap ? 'pre-wrap' : 'pre';\n\n      case 'td':\n      case 'th':\n        return node.properties.noWrap ? 'nowrap' : context.whitespace;\n\n      case 'textarea':\n        return 'pre-wrap';\n\n      default:\n    }\n  }\n\n  return context.whitespace;\n}","map":{"version":3,"sources":["/home/jacques/Documents/ece/inge4/techno web/lab/lab 4/lab/node_modules/rehype-minify-whitespace/index.js"],"names":["isElement","embedded","convert","whitespace","blocks","content","contents","skippable","skippables","ignorableNode","rehypeMinifyWhitespace","options","collapse","collapseFactory","newlines","replaceNewlines","replaceWhitespace","tree","minify","node","context","settings","Object","assign","type","blocklike","before","after","inferWhiteSpace","all","minifyText","value","remove","ignore","stripAtStart","result","start","end","length","removable","charAt","slice","parent","children","index","collapsableAfter","splice","Boolean","nodes","inferBoundary","undefined","properties","hidden","character","match","exec","replace","String","tagName","wrap","noWrap"],"mappings":"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","sourcesContent":["/**\n * @fileoverview\n *   Collapse whitespace.\n *\n *   Normally, collapses to a single space.\n *   If `newlines: true`, collapses whitespace containing newlines to `'\\n'`\n *   instead of `' '`.\n * @example\n *   <h1>Heading</h1>\n *   <p><strong>This</strong> and <em>that</em></p>\n */\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {Root|Root['children'][number]} Node\n *\n * @typedef Options\n * @property {boolean} [newlines=false]\n *   If `newlines: true`, collapses whitespace containing newlines to `'\\n'`\n *   instead of `' '`.\n *   The default is to collapse to a single space.\n *\n * @typedef {'pre'|'nowrap'|'pre-wrap'|'normal'} Whitespace\n *\n * @typedef Context\n * @property {ReturnType<collapseFactory>} collapse\n * @property {Whitespace} whitespace\n * @property {boolean} [before]\n * @property {boolean} [after]\n *\n * @typedef Result\n * @property {boolean} remove\n * @property {boolean} ignore\n * @property {boolean} stripAtStart\n */\n\nimport {isElement} from 'hast-util-is-element'\nimport {embedded} from 'hast-util-embedded'\nimport {convert} from 'unist-util-is'\nimport {whitespace} from 'hast-util-whitespace'\nimport {blocks} from './block.js'\nimport {content as contents} from './content.js'\nimport {skippable as skippables} from './skippable.js'\n\nconst ignorableNode = convert(['doctype', 'comment'])\n\n/**\n * Collapse whitespace.\n *\n * Normally, collapses to a single space.\n * If `newlines: true`, collapses whitespace containing newlines to `'\\n'`\n * instead of `' '`.\n *\n * @type {import('unified').Plugin<[Options?] | void[], Root>}\n */\nexport default function rehypeMinifyWhitespace(options = {}) {\n  const collapse = collapseFactory(\n    options.newlines ? replaceNewlines : replaceWhitespace\n  )\n\n  return (tree) => {\n    minify(tree, {collapse, whitespace: 'normal'})\n  }\n}\n\n/**\n * @param {Node} node\n * @param {Context} context\n * @returns {Result}\n */\nfunction minify(node, context) {\n  if ('children' in node) {\n    const settings = Object.assign({}, context)\n\n    if (node.type === 'root' || blocklike(node)) {\n      settings.before = true\n      settings.after = true\n    }\n\n    settings.whitespace = inferWhiteSpace(node, context)\n\n    return all(node, settings)\n  }\n\n  if (node.type === 'text') {\n    if (context.whitespace === 'normal') {\n      return minifyText(node, context)\n    }\n\n    // Naïve collapse, but no trimming:\n    if (context.whitespace === 'nowrap') {\n      node.value = context.collapse(node.value)\n    }\n\n    // The `pre-wrap` or `pre` whitespace settings are neither collapsed nor\n    // trimmed.\n  }\n\n  return {remove: false, ignore: ignorableNode(node), stripAtStart: false}\n}\n\n/**\n * @param {Text} node\n * @param {Context} context\n * @returns {Result}\n */\nfunction minifyText(node, context) {\n  const value = context.collapse(node.value)\n  const result = {remove: false, ignore: false, stripAtStart: false}\n  let start = 0\n  let end = value.length\n\n  if (context.before && removable(value.charAt(0))) {\n    start++\n  }\n\n  if (start !== end && removable(value.charAt(end - 1))) {\n    if (context.after) {\n      end--\n    } else {\n      result.stripAtStart = true\n    }\n  }\n\n  if (start === end) {\n    result.remove = true\n  } else {\n    node.value = value.slice(start, end)\n  }\n\n  return result\n}\n\n/**\n * @param {Root|Element} parent\n * @param {Context} context\n * @returns {Result}\n */\nfunction all(parent, context) {\n  let before = context.before\n  const after = context.after\n  const children = parent.children\n  let length = children.length\n  let index = -1\n\n  while (++index < length) {\n    const result = minify(\n      children[index],\n      Object.assign({}, context, {\n        before,\n        after: collapsableAfter(children, index, after)\n      })\n    )\n\n    if (result.remove) {\n      children.splice(index, 1)\n      index--\n      length--\n    } else if (!result.ignore) {\n      before = result.stripAtStart\n    }\n\n    // If this element, such as a `<select>` or `<img>`, contributes content\n    // somehow, allow whitespace again.\n    if (content(children[index])) {\n      before = false\n    }\n  }\n\n  return {remove: false, ignore: false, stripAtStart: Boolean(before || after)}\n}\n\n/**\n * @param {Node[]} nodes\n * @param {number} index\n * @param {boolean|undefined} [after]\n * @returns {boolean|undefined}\n */\nfunction collapsableAfter(nodes, index, after) {\n  while (++index < nodes.length) {\n    const node = nodes[index]\n    let result = inferBoundary(node)\n\n    if (result === undefined && 'children' in node && !skippable(node)) {\n      result = collapsableAfter(node.children, -1)\n    }\n\n    if (typeof result === 'boolean') {\n      return result\n    }\n  }\n\n  return after\n}\n\n/**\n * Infer two types of boundaries:\n *\n * 1. `true` — boundary for which whitespace around it does not contribute\n *    anything\n * 2. `false` — boundary for which whitespace around it *does* contribute\n *\n * No result (`undefined`) is returned if it is unknown.\n *\n * @param {Node} node\n * @returns {boolean|undefined}\n */\nfunction inferBoundary(node) {\n  if (node.type === 'element') {\n    if (content(node)) {\n      return false\n    }\n\n    if (blocklike(node)) {\n      return true\n    }\n\n    // Unknown: either depends on siblings if embedded or metadata, or on\n    // children.\n  } else if (node.type === 'text') {\n    if (!whitespace(node)) {\n      return false\n    }\n  } else if (!ignorableNode(node)) {\n    return false\n  }\n}\n\n/**\n * Infer whether a node is skippable.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nfunction content(node) {\n  return embedded(node) || isElement(node, contents)\n}\n\n/**\n * See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\n *\n * @param {Element} node\n * @returns {boolean}\n */\nfunction blocklike(node) {\n  return isElement(node, blocks)\n}\n\n/**\n * @param {Element|Root} node\n * @returns {boolean}\n */\nfunction skippable(node) {\n  return (\n    Boolean(\n      'properties' in node && node.properties && node.properties.hidden\n    ) ||\n    ignorableNode(node) ||\n    isElement(node, skippables)\n  )\n}\n\n/**\n * @param {string} character\n * @returns {boolean}\n */\nfunction removable(character) {\n  return character === ' ' || character === '\\n'\n}\n\n/**\n * @param {string} value\n * @returns {string}\n */\nfunction replaceNewlines(value) {\n  const match = /\\r?\\n|\\r/.exec(value)\n  return match ? match[0] : ' '\n}\n\n/**\n * @returns {string}\n */\nfunction replaceWhitespace() {\n  return ' '\n}\n\n/**\n * @param {(value: string) => string} replace\n */\nfunction collapseFactory(replace) {\n  return collapse\n\n  /**\n   * @param {string} value\n   * @returns {string}\n   */\n  function collapse(value) {\n    return String(value).replace(/[\\t\\n\\v\\f\\r ]+/g, replace)\n  }\n}\n\n/**\n * We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\n *\n * @param {Root|Element} node\n * @param {Context} context\n * @returns {Whitespace}\n */\nfunction inferWhiteSpace(node, context) {\n  if ('tagName' in node && node.properties) {\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp':\n        return 'pre'\n      case 'nobr':\n        return 'nowrap'\n      case 'pre':\n        return node.properties.wrap ? 'pre-wrap' : 'pre'\n      case 'td':\n      case 'th':\n        return node.properties.noWrap ? 'nowrap' : context.whitespace\n      case 'textarea':\n        return 'pre-wrap'\n      default:\n    }\n  }\n\n  return context.whitespace\n}\n"]},"metadata":{},"sourceType":"module"}